[
  {
    "id": "eco-strategic-001",
    "category": "modeling",
    "question": "財務プラットフォームにおいて、決算情報と株価情報を扱う必要があります。\n\n**ドメインの観察**:\n- 決算情報: 企業の財務実績を示す（売上、営業利益、純利益、発表日）\n- 株価情報: 市場での取引価格を示す（始値、高値、安値、終値、出来高）\n- 両方とも「企業の財務に関する情報」という共通点がある\n- しかし、意味や用途が大きく異なる\n\n**ビジネス要件**:\n- 決算情報と株価情報は異なる分析目的で使用される\n- それぞれ独立して更新・管理される\n- 将来的に異なる変換ルールやバリデーションが必要になる可能性がある\n\nこの2つの概念をモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "決算情報と株価情報を別々の独立した概念として扱う。共通の属性（企業ID、日付）があるが、それらは各概念の一部として定義する。\n\n**理由**: ドメイン上、決算情報と株価情報は異なる意味と用途を持つため、別々の概念として明確に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "決算情報と株価情報を「財務データ」という共通の概念の下に、typeフィールドで区別する形で統合する。\n\n**理由**: 両方とも財務に関する情報なので、1つの概念として扱うことでコードがシンプルになる。typeフィールドで区別すれば十分。",
      "決算情報と株価情報を「財務データ」という共通の概念の下に、nullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 1つの概念で全てを表現できるため、コードが最もシンプルになる。不要な属性はnullにすればよい。",
      "決算情報と株価情報を「財務データ」という共通の概念の下に、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "決算情報と株価情報は、ドメイン上異なる意味と用途を持つ概念です。決算情報は企業の財務実績を示し、株価情報は市場での取引価格を示します。これらを別々の概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（企業ID、日付）があっても、それらは各概念の文脈で意味が異なる可能性があるため、統合する必要はありません。",
      "translation": "決算情報と株価情報を別々の独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の分離] [V: 決定] [O: 決算情報と株価情報] [C: 別々の概念として扱う] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "typeフィールドで区別する方法は動作しますが、ドメインの概念を適切に表現できていません。決算情報と株価情報は単なる「タイプの違い」ではなく、異なる意味と用途を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、将来的な変更が困難になります。",
        "2": "nullableフィールドで統合する方法は、ドメインの概念を全く表現できていません。決算情報に株価の属性が含まれるというのは、ドメイン上意味がありません。また、不正な状態（決算情報なのに株価の属性がnullでない）を表現できてしまいます。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。決算情報と株価情報は単なる「フラグの違い」ではなく、異なる意味と用途を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-002",
    "category": "modeling",
    "question": "ユーザー管理において、一般ユーザー、プレミアムユーザー、アナリストユーザーを扱う必要があります。\n\n**ドメインの観察**:\n- 一般ユーザー: 基本的な機能のみ利用可能\n- プレミアムユーザー: サブスクリプション契約により追加機能を利用可能（契約開始日、プラン種別）\n- アナリストユーザー: 組織に所属し、専門的な分析機能を利用可能（所属組織、資格情報）\n- 全てのユーザーに共通する属性: 名前、メール、パスワード、登録日\n\n**ビジネス要件**:\n- ユーザータイプごとに異なる権限と機能が提供される\n- ユーザータイプは変更される可能性がある（一般→プレミアムへのアップグレードなど）\n- 各ユーザータイプで異なるビジネスルールが適用される\n\nこの3つのユーザータイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのユーザータイプを「ユーザー」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのユーザータイプは異なる意味と用途を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのユーザータイプを「ユーザー」という1つの概念として扱い、userTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのユーザーに共通する属性が多いため、1つの概念として扱うことでコードがシンプルになる。userTypeフィールドで区別すれば十分。",
      "3つのユーザータイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各ユーザータイプは異なる意味と用途を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのユーザータイプを「ユーザー」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのユーザータイプは、ドメイン上異なる意味と用途を持つ概念です。一般ユーザー、プレミアムユーザー、アナリストユーザーは、それぞれ異なる権限と機能を持ち、異なるビジネスルールが適用されます。これらを「ユーザー」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（名前、メール、パスワード、登録日）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのユーザータイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: ユーザータイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "userTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのユーザータイプは単なる「タイプの違い」ではなく、異なる意味と用途を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（一般ユーザーなのにプレミアムの属性がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのユーザータイプが「ユーザー」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのユーザータイプは単なる「フラグの違い」ではなく、異なる意味と用途を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-003",
    "category": "modeling",
    "question": "コンテンツ管理において、ニュース記事とレポートを扱う必要があります。\n\n**ドメインの観察**:\n- ニュース記事: 一般向けの情報発信（タイトル、本文、公開日、著者、タグ、閲覧数）\n- レポート: 企業向けの専門的な分析（タイトル、本文、公開日、著者、対象企業、レポート種別、PDF URL）\n- 両方とも「公開されるコンテンツ」という共通点がある\n- しかし、目的や読者層が大きく異なる\n\n**ビジネス要件**:\n- ニュース記事とレポートは異なる公開ルールとアクセス制御が適用される\n- それぞれ独立して管理・更新される\n- 将来的に異なる分析や集計が必要になる可能性がある\n\nこの2つの概念をモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "ニュース記事とレポートを「コンテンツ」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、ニュース記事とレポートは異なる目的と読者層を持つため、それぞれ独立した概念として明確に分離すべき。しかし、両方とも「公開されるコンテンツ」という共通点があるため、共通の概念の下に定義することで、ドメインの理解が深まる。",
      "ニュース記事とレポートを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: ニュース記事とレポートは異なる目的と読者層を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "ニュース記事とレポートを「コンテンツ」という1つの概念として扱い、contentTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 両方ともコンテンツなので、1つの概念として扱うことでコードがシンプルになる。contentTypeフィールドで区別すれば十分。",
      "ニュース記事とレポートを「コンテンツ」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "ニュース記事とレポートは、ドメイン上異なる目的と読者層を持つ概念です。ニュース記事は一般向けの情報発信、レポートは企業向けの専門的な分析です。これらを「コンテンツ」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（タイトル、本文、公開日、著者）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "ニュース記事とレポートを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: ニュース記事とレポート] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、両方とも「公開されるコンテンツ」という共通点があるというドメインの理解が表現できていません。",
        "2": "contentTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。ニュース記事とレポートは単なる「タイプの違い」ではなく、異なる目的と読者層を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（ニュース記事なのにレポートの属性がnullでない）を表現できてしまいます。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。ニュース記事とレポートは単なる「フラグの違い」ではなく、異なる目的と読者層を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-004",
    "category": "modeling",
    "question": "データソース管理において、APIデータソース、スクレイピングデータソース、手動入力データソースを扱う必要があります。\n\n**ドメインの観察**:\n- APIデータソース: 外部APIから自動的にデータを取得（エンドポイントURL、認証情報、更新頻度）\n- スクレイピングデータソース: Webページから自動的にデータを取得（スクレイピングURL、セレクター、更新頻度）\n- 手動入力データソース: ユーザーが手動でデータを入力（入力者、最終更新日時）\n- 全てのデータソースに共通する属性: 名前\n- しかし、データ取得方法や管理方法が大きく異なる\n\n**ビジネス要件**:\n- 各データソースタイプで異なる更新ロジックとバリデーションが必要\n- それぞれ独立して管理・設定される\n- 将来的に異なる変換ルールやエラーハンドリングが必要になる可能性がある\n\nこの3つのデータソースタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのデータソースタイプを「データソース」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのデータソースタイプは異なるデータ取得方法と管理方法を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのデータソースタイプを「データソース」という1つの概念として扱い、sourceTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのデータソースに共通する属性（名前）があるため、1つの概念として扱うことでコードがシンプルになる。sourceTypeフィールドで区別すれば十分。",
      "3つのデータソースタイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各データソースタイプは異なるデータ取得方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのデータソースタイプを「データソース」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのデータソースタイプは、ドメイン上異なるデータ取得方法と管理方法を持つ概念です。APIデータソース、スクレイピングデータソース、手動入力データソースは、それぞれ異なる更新ロジックとバリデーションを持ち、異なるビジネスルールが適用されます。これらを「データソース」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（名前）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのデータソースタイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: データソースタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "sourceTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのデータソースタイプは単なる「タイプの違い」ではなく、異なるデータ取得方法と管理方法を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（APIデータソースなのに手動入力の属性がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのデータソースタイプが「データソース」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのデータソースタイプは単なる「フラグの違い」ではなく、異なるデータ取得方法と管理方法を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-005",
    "category": "modeling",
    "question": "サブスクリプション管理において、月額プランと年額プランを扱う必要があります。\n\n**ドメインの観察**:\n- 月額プラン: 毎月の支払いサイクルで提供されるサービス（月額料金、開始日、次回請求日）\n- 年額プラン: 年間の支払いサイクルで提供されるサービス（年額料金、開始日、次回請求日、年間割引率）\n- 両方とも「サブスクリプションプラン」という共通点がある\n- しかし、支払いサイクルや料金体系が異なる\n\n**ビジネス要件**:\n- 月額プランと年額プランは異なる請求ロジックと割引計算が必要\n- それぞれ独立して管理・更新される\n- 将来的に異なるキャンセルポリシーやアップグレードルールが必要になる可能性がある\n\nこの2つのプランタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "月額プランと年額プランを「サブスクリプションプラン」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、月額プランと年額プランは異なる支払いサイクルと料金体系を持つため、それぞれ独立した概念として明確に分離すべき。しかし、両方とも「サブスクリプションプラン」という共通点があるため、共通の概念の下に定義することで、ドメインの理解が深まる。",
      "月額プランと年額プランを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 月額プランと年額プランは異なる支払いサイクルを持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "月額プランと年額プランを「サブスクリプションプラン」という1つの概念として扱い、planTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 両方ともサブスクリプションプランなので、1つの概念として扱うことでコードがシンプルになる。planTypeフィールドで区別すれば十分。",
      "月額プランと年額プランを「サブスクリプションプラン」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "月額プランと年額プランは、ドメイン上異なる支払いサイクルと料金体系を持つ概念です。月額プランは毎月の支払いサイクル、年額プランは年間の支払いサイクルです。これらを「サブスクリプションプラン」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（プラン名、開始日、次回請求日）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "月額プランと年額プランを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: プランタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、両方とも「サブスクリプションプラン」という共通点があるというドメインの理解が表現できていません。",
        "2": "planTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。月額プランと年額プランは単なる「タイプの違い」ではなく、異なる支払いサイクルと料金体系を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（月額プランなのに年額料金がnullでない）を表現できてしまいます。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。月額プランと年額プランは単なる「フラグの違い」ではなく、異なる支払いサイクルと料金体系を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-006",
    "category": "modeling",
    "question": "通知システムにおいて、メール通知、プッシュ通知、SMS通知を扱う必要があります。\n\n**ドメインの観察**:\n- メール通知: メールアドレス宛に送信される通知（宛先、件名、本文、送信日時）\n- プッシュ通知: モバイルアプリに送信される通知（デバイストークン、タイトル、本文、送信日時、優先度）\n- SMS通知: 電話番号宛に送信される通知（電話番号、本文、送信日時、送信ステータス）\n- 全ての通知に共通する属性: 本文、送信日時\n- しかし、送信方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各通知タイプで異なる送信ロジックとエラーハンドリングが必要\n- それぞれ独立して管理・送信される\n- 将来的に異なるリトライポリシーや配信保証が必要になる可能性がある\n\nこの3つの通知タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの通知タイプを「通知」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの通知タイプは異なる送信方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの通知タイプを「通知」という1つの概念として扱い、notificationTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての通知に共通する属性（本文、送信日時）があるため、1つの概念として扱うことでコードがシンプルになる。notificationTypeフィールドで区別すれば十分。",
      "3つの通知タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各通知タイプは異なる送信方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの通知タイプを「通知」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの通知タイプは、ドメイン上異なる送信方法と必要な情報を持つ概念です。メール通知、プッシュ通知、SMS通知は、それぞれ異なる送信ロジックとエラーハンドリングを持ち、異なるビジネスルールが適用されます。これらを「通知」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（本文、送信日時）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの通知タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 通知タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "notificationTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの通知タイプは単なる「タイプの違い」ではなく、異なる送信方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（メール通知なのにデバイストークンがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの通知タイプが「通知」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの通知タイプは単なる「フラグの違い」ではなく、異なる送信方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-007",
    "category": "modeling",
    "question": "検索機能において、企業検索、ニュース検索、レポート検索を扱う必要があります。\n\n**ドメインの観察**:\n- 企業検索: 企業情報を検索する（クエリ文字列、業種フィルター、上場/非上場フィルター、ソート順）\n- ニュース検索: ニュース記事を検索する（クエリ文字列、日付範囲フィルター、タグフィルター、ソート順）\n- レポート検索: レポートを検索する（クエリ文字列、対象企業フィルター、レポート種別フィルター、ソート順）\n- 全ての検索に共通する属性: クエリ文字列、ソート順\n- しかし、検索対象やフィルター条件が大きく異なる\n\n**ビジネス要件**:\n- 各検索タイプで異なる検索ロジックとインデックスが必要\n- それぞれ独立して管理・実行される\n- 将来的に異なる検索アルゴリズムやランキングロジックが必要になる可能性がある\n\nこの3つの検索タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの検索タイプを「検索リクエスト」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの検索タイプは異なる検索対象とフィルター条件を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの検索タイプを「検索リクエスト」という1つの概念として扱い、searchTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての検索に共通する属性（クエリ文字列、ソート順）があるため、1つの概念として扱うことでコードがシンプルになる。searchTypeフィールドで区別すれば十分。",
      "3つの検索タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各検索タイプは異なる検索対象を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの検索タイプを「検索リクエスト」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの検索タイプは、ドメイン上異なる検索対象とフィルター条件を持つ概念です。企業検索、ニュース検索、レポート検索は、それぞれ異なる検索ロジックとインデックスを持ち、異なるビジネスルールが適用されます。これらを「検索リクエスト」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（クエリ文字列、ソート順）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの検索タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 検索タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "searchTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの検索タイプは単なる「タイプの違い」ではなく、異なる検索対象とフィルター条件を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（企業検索なのに日付範囲フィルターがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの検索タイプが「検索リクエスト」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの検索タイプは単なる「フラグの違い」ではなく、異なる検索対象とフィルター条件を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-008",
    "category": "modeling",
    "question": "データ可視化において、グラフ、テーブル、ダッシュボードを扱う必要があります。\n\n**ドメインの観察**:\n- グラフ: データを視覚的にグラフで表示（タイトル、データソース、グラフ種別、設定）\n- テーブル: データを表形式で表示（タイトル、データソース、列定義、ソート設定）\n- ダッシュボード: 複数のグラフやテーブルを組み合わせて表示（タイトル、含まれるグラフ・テーブルのリスト、レイアウト設定）\n- 全ての可視化に共通する属性: タイトル、データソース\n- しかし、表示方法や構成要素が大きく異なる\n\n**ビジネス要件**:\n- 各可視化タイプで異なるレンダリングロジックと設定が必要\n- それぞれ独立して管理・更新される\n- 将来的に異なるインタラクション機能やエクスポート機能が必要になる可能性がある\n\nこの3つの可視化タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの可視化タイプを「可視化」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの可視化タイプは異なる表示方法と構成要素を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの可視化タイプを「可視化」という1つの概念として扱い、visualizationTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての可視化に共通する属性（タイトル、データソース）があるため、1つの概念として扱うことでコードがシンプルになる。visualizationTypeフィールドで区別すれば十分。",
      "3つの可視化タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各可視化タイプは異なる表示方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの可視化タイプを「可視化」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの可視化タイプは、ドメイン上異なる表示方法と構成要素を持つ概念です。グラフ、テーブル、ダッシュボードは、それぞれ異なるレンダリングロジックと設定を持ち、異なるビジネスルールが適用されます。これらを「可視化」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（タイトル、データソース）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの可視化タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 可視化タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "visualizationTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの可視化タイプは単なる「タイプの違い」ではなく、異なる表示方法と構成要素を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（グラフなのに列定義がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの可視化タイプが「可視化」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの可視化タイプは単なる「フラグの違い」ではなく、異なる表示方法と構成要素を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-009",
    "category": "modeling",
    "question": "レポート生成において、PDFレポート、Excelレポート、HTMLレポートを扱う必要があります。\n\n**ドメインの観察**:\n- PDFレポート: PDF形式で生成されるレポート（タイトル、コンテンツ、テンプレート、生成日時、ファイルサイズ）\n- Excelレポート: Excel形式で生成されるレポート（タイトル、シートリスト、テンプレート、生成日時、ファイルサイズ）\n- HTMLレポート: HTML形式で生成されるレポート（タイトル、HTMLコンテンツ、スタイルシート、生成日時、URL）\n- 全てのレポートに共通する属性: タイトル、生成日時\n- しかし、出力形式や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各レポートタイプで異なる生成ロジックとテンプレートが必要\n- それぞれ独立して管理・生成される\n- 将来的に異なるエクスポート機能や配信方法が必要になる可能性がある\n\nこの3つのレポートタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのレポートタイプを「レポート」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのレポートタイプは異なる出力形式と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのレポートタイプを「レポート」という1つの概念として扱い、reportTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのレポートに共通する属性（タイトル、生成日時）があるため、1つの概念として扱うことでコードがシンプルになる。reportTypeフィールドで区別すれば十分。",
      "3つのレポートタイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各レポートタイプは異なる出力形式を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのレポートタイプを「レポート」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのレポートタイプは、ドメイン上異なる出力形式と必要な情報を持つ概念です。PDFレポート、Excelレポート、HTMLレポートは、それぞれ異なる生成ロジックとテンプレートを持ち、異なるビジネスルールが適用されます。これらを「レポート」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（タイトル、生成日時）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのレポートタイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: レポートタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "reportTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのレポートタイプは単なる「タイプの違い」ではなく、異なる出力形式と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（PDFレポートなのにシートリストがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのレポートタイプが「レポート」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのレポートタイプは単なる「フラグの違い」ではなく、異なる出力形式と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-010",
    "category": "modeling",
    "question": "アラート設定において、価格アラート、ニュースアラート、財務指標アラートを扱う必要があります。\n\n**ドメインの観察**:\n- 価格アラート: 株価が特定の条件を満たしたときに通知（企業ID、閾値、条件、通知方法）\n- ニュースアラート: 特定のキーワードを含むニュースが公開されたときに通知（キーワードリスト、通知方法）\n- 財務指標アラート: 財務指標が特定の条件を満たしたときに通知（企業ID、指標種別、閾値、条件、通知方法）\n- 全てのアラートに共通する属性: 通知方法\n- しかし、監視対象や条件設定が大きく異なる\n\n**ビジネス要件**:\n- 各アラートタイプで異なる監視ロジックと評価条件が必要\n- それぞれ独立して管理・設定される\n- 将来的に異なる通知頻度や集約ルールが必要になる可能性がある\n\nこの3つのアラートタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのアラートタイプを「アラート」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのアラートタイプは異なる監視対象と条件設定を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのアラートタイプを「アラート」という1つの概念として扱い、alertTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのアラートに共通する属性（通知方法）があるため、1つの概念として扱うことでコードがシンプルになる。alertTypeフィールドで区別すれば十分。",
      "3つのアラートタイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各アラートタイプは異なる監視対象を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのアラートタイプを「アラート」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのアラートタイプは、ドメイン上異なる監視対象と条件設定を持つ概念です。価格アラート、ニュースアラート、財務指標アラートは、それぞれ異なる監視ロジックと評価条件を持ち、異なるビジネスルールが適用されます。これらを「アラート」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（通知方法）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのアラートタイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: アラートタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "alertTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのアラートタイプは単なる「タイプの違い」ではなく、異なる監視対象と条件設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（価格アラートなのにキーワードリストがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのアラートタイプが「アラート」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのアラートタイプは単なる「フラグの違い」ではなく、異なる監視対象と条件設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-011",
    "category": "modeling",
    "question": "認証情報管理において、APIキー認証、OAuth認証、基本認証を扱う必要があります。\n\n**ドメインの観察**:\n- APIキー認証: APIキーによる認証（APIキー、有効期限）\n- OAuth認証: OAuthプロトコルによる認証（アクセストークン、リフレッシュトークン、有効期限、スコープ）\n- 基本認証: ユーザー名とパスワードによる認証（ユーザー名、パスワード）\n- APIキー認証とOAuth認証は有効期限を持つが、基本認証は持たない\n- しかし、認証方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各認証タイプで異なる認証ロジックとトークン管理が必要\n- それぞれ独立して管理・更新される\n- 将来的に異なるリフレッシュポリシーやセキュリティ要件が必要になる可能性がある\n\nこの3つの認証タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの認証タイプを「認証情報」という共通の概念の下に、それぞれ独立した概念として扱う。APIキー認証とOAuth認証は有効期限を持つため、共通の概念に有効期限を定義するが、基本認証は有効期限を持たないため、別途定義する。各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの認証タイプは異なる認証方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの認証タイプを「認証情報」という1つの概念として扱い、authTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての認証情報に共通する属性があるため、1つの概念として扱うことでコードがシンプルになる。authTypeフィールドで区別すれば十分。",
      "3つの認証タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各認証タイプは異なる認証方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの認証タイプを「認証情報」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの認証タイプは、ドメイン上異なる認証方法と必要な情報を持つ概念です。APIキー認証、OAuth認証、基本認証は、それぞれ異なる認証ロジックとトークン管理を持ち、異なるビジネスルールが適用されます。これらを「認証情報」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。APIキー認証とOAuth認証は有効期限を持つため、共通の概念に有効期限を定義しますが、基本認証は有効期限を持たないため、別途定義します。",
      "translation": "3つの認証タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 認証タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "authTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの認証タイプは単なる「タイプの違い」ではなく、異なる認証方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（APIキー認証なのにアクセストークンがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの認証タイプが「認証情報」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの認証タイプは単なる「フラグの違い」ではなく、異なる認証方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-012",
    "category": "modeling",
    "question": "データ更新履歴管理において、自動更新と手動更新を扱う必要があります。\n\n**ドメインの観察**:\n- 自動更新: システムが自動的にデータを更新（データソースID、更新日時、更新ステータス、エラーメッセージ）\n- 手動更新: ユーザーが手動でデータを更新（データソースID、更新日時、更新者、更新理由）\n- 両方とも「データ更新履歴」という共通点がある\n- しかし、更新方法や記録すべき情報が大きく異なる\n\n**ビジネス要件**:\n- 自動更新と手動更新は異なる監査ロジックとエラーハンドリングが必要\n- それぞれ独立して管理・記録される\n- 将来的に異なる通知ルールや分析が必要になる可能性がある\n\nこの2つの更新タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "自動更新と手動更新を「更新履歴」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、自動更新と手動更新は異なる更新方法と記録すべき情報を持つため、それぞれ独立した概念として明確に分離すべき。しかし、両方とも「データ更新履歴」という共通点があるため、共通の概念の下に定義することで、ドメインの理解が深まる。",
      "自動更新と手動更新を完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 自動更新と手動更新は異なる更新方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "自動更新と手動更新を「更新履歴」という1つの概念として扱い、updateTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 両方とも更新履歴なので、1つの概念として扱うことでコードがシンプルになる。updateTypeフィールドで区別すれば十分。",
      "自動更新と手動更新を「更新履歴」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "自動更新と手動更新は、ドメイン上異なる更新方法と記録すべき情報を持つ概念です。自動更新はシステムが自動的に実行し、エラーメッセージを記録します。手動更新はユーザーが実行し、更新者と更新理由を記録します。これらを「更新履歴」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（データソースID、更新日時）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "自動更新と手動更新を共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 更新タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、両方とも「データ更新履歴」という共通点があるというドメインの理解が表現できていません。",
        "2": "updateTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。自動更新と手動更新は単なる「タイプの違い」ではなく、異なる更新方法と記録すべき情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（自動更新なのに更新者がnullでない）を表現できてしまいます。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。自動更新と手動更新は単なる「フラグの違い」ではなく、異なる更新方法と記録すべき情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-013",
    "category": "modeling",
    "question": "データエクスポート機能において、CSVエクスポート、JSONエクスポート、Excelエクスポートを扱う必要があります。\n\n**ドメインの観察**:\n- CSVエクスポート: CSV形式でデータをエクスポート（データソース、出力ファイル名、区切り文字、エンコーディング）\n- JSONエクスポート: JSON形式でデータをエクスポート（データソース、出力ファイル名、整形オプション）\n- Excelエクスポート: Excel形式でデータをエクスポート（データソース、出力ファイル名、シート名、書式設定）\n- 全てのエクスポートに共通する属性: データソース、出力ファイル名\n- しかし、出力形式や必要な設定が大きく異なる\n\n**ビジネス要件**:\n- 各エクスポートタイプで異なる変換ロジックとフォーマット設定が必要\n- それぞれ独立して管理・実行される\n- 将来的に異なる圧縮オプションや配信方法が必要になる可能性がある\n\nこの3つのエクスポートタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのエクスポートタイプを「エクスポートリクエスト」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのエクスポートタイプは異なる出力形式と必要な設定を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのエクスポートタイプを「エクスポートリクエスト」という1つの概念として扱い、exportTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのエクスポートに共通する属性（データソース、出力ファイル名）があるため、1つの概念として扱うことでコードがシンプルになる。exportTypeフィールドで区別すれば十分。",
      "3つのエクスポートタイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各エクスポートタイプは異なる出力形式を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのエクスポートタイプを「エクスポートリクエスト」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのエクスポートタイプは、ドメイン上異なる出力形式と必要な設定を持つ概念です。CSVエクスポート、JSONエクスポート、Excelエクスポートは、それぞれ異なる変換ロジックとフォーマット設定を持ち、異なるビジネスルールが適用されます。これらを「エクスポートリクエスト」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（データソース、出力ファイル名）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのエクスポートタイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: エクスポートタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "exportTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのエクスポートタイプは単なる「タイプの違い」ではなく、異なる出力形式と必要な設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（CSVエクスポートなのにシート名がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのエクスポートタイプが「エクスポートリクエスト」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのエクスポートタイプは単なる「フラグの違い」ではなく、異なる出力形式と必要な設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-014",
    "category": "modeling",
    "question": "データアクセス権限管理において、読み取り専用権限、読み書き権限、管理者権限を扱う必要があります。\n\n**ドメインの観察**:\n- 読み取り専用権限: データを閲覧することのみ許可（ユーザーID、対象リソース、有効期限）\n- 読み書き権限: データを閲覧・編集することを許可（ユーザーID、対象リソース、有効期限、編集可能なフィールドリスト）\n- 管理者権限: 全ての操作を許可（ユーザーID、対象リソース、有効期限）\n- 全ての権限に共通する属性: ユーザーID、対象リソース、有効期限\n- しかし、許可される操作や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各権限タイプで異なるアクセス制御ロジックとバリデーションが必要\n- それぞれ独立して管理・設定される\n- 将来的に異なる監査ログや通知が必要になる可能性がある\n\nこの3つの権限タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの権限タイプを「アクセス権限」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの権限タイプは異なる許可される操作と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの権限タイプを「アクセス権限」という1つの概念として扱い、permissionTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての権限に共通する属性（ユーザーID、対象リソース、有効期限）があるため、1つの概念として扱うことでコードがシンプルになる。permissionTypeフィールドで区別すれば十分。",
      "3つの権限タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各権限タイプは異なる許可される操作を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの権限タイプを「アクセス権限」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの権限タイプは、ドメイン上異なる許可される操作と必要な情報を持つ概念です。読み取り専用権限、読み書き権限、管理者権限は、それぞれ異なるアクセス制御ロジックとバリデーションを持ち、異なるビジネスルールが適用されます。これらを「アクセス権限」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（ユーザーID、対象リソース、有効期限）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの権限タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 権限タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "permissionTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの権限タイプは単なる「タイプの違い」ではなく、異なる許可される操作と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（読み取り専用権限なのに編集可能なフィールドリストがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの権限タイプが「アクセス権限」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの権限タイプは単なる「フラグの違い」ではなく、異なる許可される操作と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-015",
    "category": "modeling",
    "question": "データバックアップ管理において、自動バックアップと手動バックアップを扱う必要があります。\n\n**ドメインの観察**:\n- 自動バックアップ: システムが自動的にデータをバックアップ（バックアップID、データソース、バックアップ日時、保存先、保持期間）\n- 手動バックアップ: ユーザーが手動でデータをバックアップ（バックアップID、データソース、バックアップ日時、保存先、作成者、バックアップ理由）\n- 両方とも「データバックアップ」という共通点がある\n- しかし、バックアップ方法や記録すべき情報が大きく異なる\n\n**ビジネス要件**:\n- 自動バックアップと手動バックアップは異なる保持ポリシーと削除ロジックが必要\n- それぞれ独立して管理・実行される\n- 将来的に異なる復元ルールや通知が必要になる可能性がある\n\nこの2つのバックアップタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "自動バックアップと手動バックアップを「バックアップ」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、自動バックアップと手動バックアップは異なるバックアップ方法と記録すべき情報を持つため、それぞれ独立した概念として明確に分離すべき。しかし、両方とも「データバックアップ」という共通点があるため、共通の概念の下に定義することで、ドメインの理解が深まる。",
      "自動バックアップと手動バックアップを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 自動バックアップと手動バックアップは異なるバックアップ方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "自動バックアップと手動バックアップを「バックアップ」という1つの概念として扱い、backupTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 両方ともバックアップなので、1つの概念として扱うことでコードがシンプルになる。backupTypeフィールドで区別すれば十分。",
      "自動バックアップと手動バックアップを「バックアップ」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "自動バックアップと手動バックアップは、ドメイン上異なるバックアップ方法と記録すべき情報を持つ概念です。自動バックアップはシステムが自動的に実行し、保持期間を記録します。手動バックアップはユーザーが実行し、作成者とバックアップ理由を記録します。これらを「バックアップ」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（バックアップID、データソース、バックアップ日時、保存先）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "自動バックアップと手動バックアップを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: バックアップタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、両方とも「データバックアップ」という共通点があるというドメインの理解が表現できていません。",
        "2": "backupTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。自動バックアップと手動バックアップは単なる「タイプの違い」ではなく、異なるバックアップ方法と記録すべき情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（自動バックアップなのに作成者がnullでない）を表現できてしまいます。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。自動バックアップと手動バックアップは単なる「フラグの違い」ではなく、異なるバックアップ方法と記録すべき情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-016",
    "category": "modeling",
    "question": "データ同期管理において、リアルタイム同期、定期同期、手動同期を扱う必要があります。\n\n**ドメインの観察**:\n- リアルタイム同期: WebSocket接続による即座の同期（データソースID、同期開始日時、同期ステータス、WebSocket接続ID）\n- 定期同期: スケジュールに基づく定期的な同期（データソースID、同期開始日時、同期ステータス、同期間隔、次回同期予定日時）\n- 手動同期: ユーザーが手動で実行する同期（データソースID、同期開始日時、同期ステータス、実行者）\n- 全ての同期に共通する属性: データソースID、同期開始日時、同期ステータス\n- しかし、同期方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各同期タイプで異なる同期ロジックとエラーハンドリングが必要\n- それぞれ独立して管理・実行される\n- 将来的に異なるリトライポリシーや通知が必要になる可能性がある\n\nこの3つの同期タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの同期タイプを「同期ジョブ」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの同期タイプは異なる同期方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの同期タイプを「同期ジョブ」という1つの概念として扱い、syncTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての同期に共通する属性（データソースID、同期開始日時、同期ステータス）があるため、1つの概念として扱うことでコードがシンプルになる。syncTypeフィールドで区別すれば十分。",
      "3つの同期タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各同期タイプは異なる同期方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの同期タイプを「同期ジョブ」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの同期タイプは、ドメイン上異なる同期方法と必要な情報を持つ概念です。リアルタイム同期、定期同期、手動同期は、それぞれ異なる同期ロジックとエラーハンドリングを持ち、異なるビジネスルールが適用されます。これらを「同期ジョブ」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（データソースID、同期開始日時、同期ステータス）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの同期タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 同期タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "syncTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの同期タイプは単なる「タイプの違い」ではなく、異なる同期方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（リアルタイム同期なのに実行者がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの同期タイプが「同期ジョブ」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの同期タイプは単なる「フラグの違い」ではなく、異なる同期方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-017",
    "category": "modeling",
    "question": "データ検証において、必須チェック、形式チェック、範囲チェックを扱う必要があります。\n\n**ドメインの観察**:\n- 必須チェック: フィールドが存在することを確認（フィールド名、エラーメッセージ）\n- 形式チェック: フィールドの形式が正しいことを確認（フィールド名、エラーメッセージ、正規表現パターン）\n- 範囲チェック: フィールドの値が範囲内であることを確認（フィールド名、エラーメッセージ、最小値、最大値）\n- 全ての検証ルールに共通する属性: フィールド名、エラーメッセージ\n- しかし、検証方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各検証タイプで異なる検証ロジックとエラーハンドリングが必要\n- それぞれ独立して管理・適用される\n- 将来的に異なる検証順序や組み合わせが必要になる可能性がある\n\nこの3つの検証タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの検証タイプを「検証ルール」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの検証タイプは異なる検証方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの検証タイプを「検証ルール」という1つの概念として扱い、ruleTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての検証ルールに共通する属性（フィールド名、エラーメッセージ）があるため、1つの概念として扱うことでコードがシンプルになる。ruleTypeフィールドで区別すれば十分。",
      "3つの検証タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各検証タイプは異なる検証方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの検証タイプを「検証ルール」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの検証タイプは、ドメイン上異なる検証方法と必要な情報を持つ概念です。必須チェック、形式チェック、範囲チェックは、それぞれ異なる検証ロジックとエラーハンドリングを持ち、異なるビジネスルールが適用されます。これらを「検証ルール」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（フィールド名、エラーメッセージ）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの検証タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 検証タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "ruleTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの検証タイプは単なる「タイプの違い」ではなく、異なる検証方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（必須チェックなのに正規表現パターンがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの検証タイプが「検証ルール」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの検証タイプは単なる「フラグの違い」ではなく、異なる検証方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-018",
    "category": "modeling",
    "question": "データ変換において、フォーマット変換、単位変換、集計変換を扱う必要があります。\n\n**ドメインの観察**:\n- フォーマット変換: データの形式を変更する（入力データ、出力フォーマット、変換ルール）\n- 単位変換: データの単位を変更する（入力データ、出力単位、変換係数）\n- 集計変換: データを集計する（入力データ、集計関数、グループ化キー）\n- 全ての変換に共通する属性: 入力データ\n- しかし、変換方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各変換タイプで異なる変換ロジックと計算方法が必要\n- それぞれ独立して管理・実行される\n- 将来的に異なるエラーハンドリングや検証が必要になる可能性がある\n\nこの3つの変換タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの変換タイプを「データ変換」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの変換タイプは異なる変換方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの変換タイプを「データ変換」という1つの概念として扱い、transformationTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての変換に共通する属性（入力データ）があるため、1つの概念として扱うことでコードがシンプルになる。transformationTypeフィールドで区別すれば十分。",
      "3つの変換タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各変換タイプは異なる変換方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの変換タイプを「データ変換」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの変換タイプは、ドメイン上異なる変換方法と必要な情報を持つ概念です。フォーマット変換、単位変換、集計変換は、それぞれ異なる変換ロジックと計算方法を持ち、異なるビジネスルールが適用されます。これらを「データ変換」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（入力データ）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの変換タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 変換タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "transformationTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの変換タイプは単なる「タイプの違い」ではなく、異なる変換方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（フォーマット変換なのに変換係数がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの変換タイプが「データ変換」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの変換タイプは単なる「フラグの違い」ではなく、異なる変換方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-019",
    "category": "modeling",
    "question": "データキャッシュ管理において、メモリキャッシュ、ディスクキャッシュ、分散キャッシュを扱う必要があります。\n\n**ドメインの観察**:\n- メモリキャッシュ: メモリ上にデータを保存（キャッシュキー、データ、有効期限、最大サイズ）\n- ディスクキャッシュ: ディスク上にデータを保存（キャッシュキー、データ、有効期限、ファイルパス、圧縮設定）\n- 分散キャッシュ: 複数のノードにデータを分散保存（キャッシュキー、データ、有効期限、ノードリスト、レプリケーション設定）\n- 全てのキャッシュに共通する属性: キャッシュキー、データ、有効期限\n- しかし、保存方法や必要な設定が大きく異なる\n\n**ビジネス要件**:\n- 各キャッシュタイプで異なる保存ロジックと管理方法が必要\n- それぞれ独立して管理・運用される\n- 将来的に異なるパフォーマンス最適化や障害対応が必要になる可能性がある\n\nこの3つのキャッシュタイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つのキャッシュタイプを「キャッシュエントリ」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つのキャッシュタイプは異なる保存方法と必要な設定を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つのキャッシュタイプを「キャッシュエントリ」という1つの概念として扱い、cacheTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全てのキャッシュに共通する属性（キャッシュキー、データ、有効期限）があるため、1つの概念として扱うことでコードがシンプルになる。cacheTypeフィールドで区別すれば十分。",
      "3つのキャッシュタイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各キャッシュタイプは異なる保存方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つのキャッシュタイプを「キャッシュエントリ」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つのキャッシュタイプは、ドメイン上異なる保存方法と必要な設定を持つ概念です。メモリキャッシュ、ディスクキャッシュ、分散キャッシュは、それぞれ異なる保存ロジックと管理方法を持ち、異なるビジネスルールが適用されます。これらを「キャッシュエントリ」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（キャッシュキー、データ、有効期限）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つのキャッシュタイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: キャッシュタイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "cacheTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つのキャッシュタイプは単なる「タイプの違い」ではなく、異なる保存方法と必要な設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（メモリキャッシュなのにファイルパスがnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つのキャッシュタイプが「キャッシュエントリ」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つのキャッシュタイプは単なる「フラグの違い」ではなく、異なる保存方法と必要な設定を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  },
  {
    "id": "eco-strategic-020",
    "category": "modeling",
    "question": "データ分析において、時系列分析、統計分析、機械学習分析を扱う必要があります。\n\n**ドメインの観察**:\n- 時系列分析: 時系列データを分析する（データソース、分析期間、時系列関数、出力形式）\n- 統計分析: 統計的手法でデータを分析する（データソース、統計関数、出力形式）\n- 機械学習分析: 機械学習モデルでデータを分析する（データソース、モデル種別、学習パラメータ、出力形式）\n- 全ての分析に共通する属性: データソース、出力形式\n- しかし、分析方法や必要な情報が大きく異なる\n\n**ビジネス要件**:\n- 各分析タイプで異なる分析ロジックと計算方法が必要\n- それぞれ独立して管理・実行される\n- 将来的に異なるパフォーマンス要件や精度要件が必要になる可能性がある\n\nこの3つの分析タイプをモデリングする際、最も適切な概念の分離方法はどれですか？",
    "options": [
      "3つの分析タイプを「分析リクエスト」という共通の概念の下に、それぞれ独立した概念として扱う。共通の属性は共通の概念に定義し、各タイプ固有の属性は各概念に定義する。\n\n**理由**: ドメイン上、3つの分析タイプは異なる分析方法と必要な情報を持つため、それぞれ独立した概念として明確に分離すべき。共通の属性があることは、共通の概念を定義する理由になるが、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる。",
      "3つの分析タイプを「分析リクエスト」という1つの概念として扱い、analysisTypeフィールドとnullableフィールドで全ての属性を含む形で統合する。\n\n**理由**: 全ての分析に共通する属性（データソース、出力形式）があるため、1つの概念として扱うことでコードがシンプルになる。analysisTypeフィールドで区別すれば十分。",
      "3つの分析タイプを完全に別々の独立した概念として扱う。共通の属性があっても、それぞれの概念に定義する。\n\n**理由**: 各分析タイプは異なる分析方法を持つため、完全に分離すべき。共通の属性があっても、それらは各概念の文脈で意味が異なる可能性がある。",
      "3つの分析タイプを「分析リクエスト」という1つの概念として扱い、Booleanフラグで区別する形で統合する。\n\n**理由**: フラグで区別すれば、1つの概念として扱える。コードがシンプルで理解しやすい。"
    ],
    "correctAnswer": 0,
    "explanation": {
      "text": "3つの分析タイプは、ドメイン上異なる分析方法と必要な情報を持つ概念です。時系列分析、統計分析、機械学習分析は、それぞれ異なる分析ロジックと計算方法を持ち、異なるビジネスルールが適用されます。これらを「分析リクエスト」という共通の概念の下に、それぞれ独立した概念として明確に分離することで、それぞれの概念の責務が明確になり、将来的な変更にも柔軟に対応できます。共通の属性（データソース、出力形式）は共通の概念に定義し、各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になります。",
      "translation": "3つの分析タイプを共通の概念の下に、それぞれ独立した概念として扱うことで、それぞれの責務が明確になり、ドメインの理解が深まります。",
      "structure": "[S: 概念の階層化] [V: 決定] [O: 分析タイプ] [C: 共通概念の下に分離] [RC: 各概念の責務が明確になる]",
      "wrongOptionExplanations": {
        "1": "analysisTypeフィールドとnullableフィールドで統合する方法は動作しますが、ドメインの概念を適切に表現できていません。3つの分析タイプは単なる「タイプの違い」ではなく、異なる分析方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になり、不正な状態（時系列分析なのに統計関数がnullでない）を表現できてしまいます。",
        "2": "完全に別々の概念として扱う方法も動作しますが、共通の属性が重複して定義されるため、コードの重複が発生します。また、3つの分析タイプが「分析リクエスト」という共通の概念の下にあるというドメインの理解が表現できていません。",
        "3": "Booleanフラグで区別する方法も、ドメインの概念を適切に表現できていません。3つの分析タイプは単なる「フラグの違い」ではなく、異なる分析方法と必要な情報を持つ別々の概念です。統合することで、それぞれの概念の責務が曖昧になります。"
      }
    },
    "difficulty": 2
  }
]
