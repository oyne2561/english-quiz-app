# DDDとモデリング：具体と抽象を行き来する

ドメイン駆動設計（Domain-Driven Design, DDD）とモデリングの学習を通じて、具体と抽象を行き来する思考力を身につけましょう。

## DDDとは？

**ドメイン駆動設計（Domain-Driven Design）**は、ソフトウェア開発において、ビジネスのドメイン（領域）を深く理解し、その知識をコードに反映させる設計手法です。

### 基本原則

1. **ドメインの理解**: ビジネスの本質を理解する
2. **ユビキタス言語**: 開発者とビジネス担当者が共通の言葉を使う
3. **モデルの抽象化**: 複雑な現実を適切に抽象化する
4. **具体と抽象の往復**: 具体例から抽象化し、抽象から具体例を導く

## モデリングの本質：概念の分離と責務の明確化

モデリングの本質は、**ドメインの概念を適切に分離し、それぞれの責務を明確にすること**です。コードのテクニック（nullableを減らす、enumをどう使うか…）に入る前に、次の点が特に重要です。

### 1. ドメインの言葉で考える（ユビキタス言語）

画面項目名やDBカラム名ではなく、「ビジネス側が日常で使っている言葉」でモデルを作ります。用語の意味が曖昧なままクラスやフィールドを増やさないことが重要です。

**例**:
- ❌ 悪い: `userType: String`（"admin", "regular"など）
- ✅ 良い: 「管理者ユーザー」と「一般ユーザー」を別々の概念として扱う

### 2. 概念の分離：なぜ分離するのか？

ドメイン上、異なる意味と用途を持つ概念は、**別々の概念として明確に分離**すべきです。これは、それぞれの概念が異なる責務を持ち、異なるビジネスルールが適用されるためです。

**分離すべき概念の特徴**:
- 異なる意味と用途を持つ
- 異なるビジネスルールが適用される
- 独立して管理・更新される
- 将来的に異なる変更が必要になる可能性がある

**統合すべき概念の特徴**:
- 同じ意味と用途を持つ
- 同じビジネスルールが適用される
- 常に一緒に管理・更新される

### 3. 不正な状態を表現できないモデルにする

「この組み合わせは現実では絶対に起きない」という状態を、コード上でも作れないようにします。そのために、概念の分離、値オブジェクト、ポリモーフィズムなどを使います。

## 具体と抽象を行き来する思考プロセス

モデリングの上達には、**具体と抽象を行き来する**ことが重要です。この思考プロセスを自然にできるようになることが、良いモデリングの鍵です。

### ステップ1: 具体例を観察する（ドメインの観察）

まず、ドメインの現実を観察します。複数の具体例を集め、それぞれの特徴を理解します。

**観察のポイント**:
- この概念は何を表しているか？
- どのような属性を持っているか？
- どのような用途で使われるか？
- 他の概念とどのような関係があるか？

### ステップ2: 共通点と違いを見つける（抽象化への準備）

具体例を比較し、共通点と違いを明確にします。

**質問**:
- これらの具体例に共通する属性は何か？
- それぞれの具体例に固有の属性は何か？
- これらの具体例は、同じ概念として扱えるか？それとも別々の概念として扱うべきか？

### ステップ3: 概念の分離を決定する（抽象化）

共通点と違いを基に、概念を分離するか統合するかを決定します。

**判断基準**:
- **分離する**: 異なる意味と用途を持つ、異なるビジネスルールが適用される
- **統合する**: 同じ意味と用途を持つ、同じビジネスルールが適用される

### ステップ4: 抽象的なモデルを設計する（抽象化）

概念の分離を決定したら、抽象的なモデルを設計します。

**設計のポイント**:
- 共通の属性は共通の概念に定義する
- 各概念に固有の属性は各概念に定義する
- 各概念の責務を明確にする

### ステップ5: 具体例で検証する（具体化）

抽象化したモデルが、元の具体例を正しく表現できるか確認します。

**検証のポイント**:
- 全ての具体例を表現できるか？
- 不正な状態を作れないか？
- ドメインの理解を正しく表現できているか？

### ステップ6: 抽象と具体を往復する（継続的な改善）

抽象化したモデルから、新しい具体例を導き、その具体例からさらに抽象化を改善します。この往復を繰り返すことで、モデルが洗練されていきます。

## なぜsealed class（sealed interface）を使わないのか？

**重要な原則**: sealed class（sealed interface）を使う時点で、モデリングに失敗している可能性が高いです。

### sealed classがモデリングの失敗を示す理由

#### 1. ドメインの概念を適切に分離できていない

sealed classは、**「同じ概念の異なる状態」**を表現するために使われます。しかし、多くの場合、これは**「異なる概念を同じ概念として扱っている」**という問題を示しています。

**例：注文の状態をsealed classで表現する場合**

```kotlin
// ❌ 悪い例：sealed classで状態を表現
sealed interface Order {
    val orderId: String
}

data class PendingOrder(...) : Order
data class PaidOrder(...) : Order
data class ShippedOrder(...) : Order
```

**問題点**:
- 「注文」という1つの概念として扱っているが、実際には「未確定注文」「確定注文」「発送済み注文」は異なる概念
- それぞれ異なる責務とビジネスルールを持つ
- 状態遷移ではなく、概念の変換として扱うべき

**✅ 良い例：概念を分離する**

「未確定注文」と「確定注文」は、ドメイン上異なる概念として扱います：

- **未確定注文**: ユーザーが作成中で、まだ確定していない注文
- **確定注文**: ユーザーが確定し、支払いが完了した注文

これらを別々の概念として扱うことで、それぞれの責務が明確になります。

#### 2. 状態遷移ではなく、概念の変換として扱うべき

sealed classを使うと、状態遷移として扱いがちになります。しかし、多くの場合、これは**概念の変換**として扱うべきです。

**例：予約システム**

```kotlin
// ❌ 悪い例：sealed classで状態遷移を表現
sealed interface Reservation {
    fun confirm(): ConfirmedReservation
    fun cancel(): CancelledReservation
}
```

**問題点**:
- 「予約」という1つの概念として扱っている
- 状態遷移として扱っているが、実際には「仮予約」と「確定予約」は異なる概念

**✅ 良い例：概念を分離する**

「仮予約」と「確定予約」は、ドメイン上異なる概念として扱います：

- **仮予約**: ユーザーが仮に予約したが、まだ確定していない予約
- **確定予約**: ユーザーが確定し、システムが承認した予約

これらを別々の概念として扱うことで、それぞれの責務が明確になります。

#### 3. 拡張性と柔軟性の欠如

sealed classを使うと、新しい状態を追加する際に、既存のコードを変更する必要があります。これは、Open-Closed原則に反します。

**例：新しい状態を追加する場合**

```kotlin
// sealed classを使っている場合
sealed interface Order {
    val orderId: String
}

data class PendingOrder(...) : Order
data class PaidOrder(...) : Order
data class ShippedOrder(...) : Order
// 新しい状態「返品済み注文」を追加する場合、既存のコードを変更する必要がある
data class ReturnedOrder(...) : Order  // 既存のwhen式を全て更新する必要がある
```

**問題点**:
- 新しい状態を追加する際に、既存のコードを変更する必要がある
- 既存のコードに影響を与える可能性がある

**✅ 良い例：概念を分離する**

概念を分離することで、新しい概念を追加しても、既存のコードに影響を与えません。

#### 4. ドメインの理解が浅い

sealed classを使うと、ドメインの理解が浅いまま、技術的な解決策（状態遷移）に逃げてしまう可能性があります。

**例：ブログ投稿の状態**

```kotlin
// ❌ 悪い例：sealed classで状態を表現
sealed interface BlogPost {
    val id: String
    val title: String
    val content: String
}

data class DraftPost(...) : BlogPost
data class PublishedPost(...) : BlogPost
data class ArchivedPost(...) : BlogPost
```

**問題点**:
- 「ブログ投稿」という1つの概念として扱っている
- 「下書き」「公開済み」「アーカイブ済み」は、実際には異なる概念として扱うべき

**✅ 良い例：概念を分離する**

「下書き」「公開済み投稿」「アーカイブ済み投稿」は、ドメイン上異なる概念として扱います：

- **下書き**: 作成中で、まだ公開されていない投稿
- **公開済み投稿**: 公開され、読者が閲覧できる投稿
- **アーカイブ済み投稿**: アーカイブされ、過去の投稿として扱われる投稿

これらを別々の概念として扱うことで、それぞれの責務が明確になります。

### sealed classを使うべきでない理由のまとめ

1. **ドメインの概念を適切に分離できていない**: sealed classは「同じ概念の異なる状態」を表現するが、実際には「異なる概念」として扱うべき
2. **状態遷移ではなく、概念の変換として扱うべき**: sealed classを使うと状態遷移として扱いがちになるが、実際には概念の変換として扱うべき
3. **拡張性と柔軟性の欠如**: 新しい状態を追加する際に、既存のコードを変更する必要がある
4. **ドメインの理解が浅い**: sealed classを使うと、ドメインの理解が浅いまま、技術的な解決策に逃げてしまう

### 代わりに何を使うべきか？

sealed classの代わりに、**概念を分離し、それぞれを独立した概念として扱う**べきです。共通の属性がある場合は、共通の概念（interface）を定義し、各概念に固有の属性は各概念に定義します。

**例：注文システム**

```kotlin
// ✅ 良い例：概念を分離する
interface Order {
    val orderId: String
    val customerId: String
    val items: List<OrderItem>
}

// 未確定注文：ユーザーが作成中で、まだ確定していない注文
data class PendingOrder(
    override val orderId: String,
    override val customerId: String,
    override val items: List<OrderItem>
) : Order

// 確定注文：ユーザーが確定し、支払いが完了した注文
data class ConfirmedOrder(
    override val orderId: String,
    override val customerId: String,
    override val items: List<OrderItem>,
    val paymentDate: LocalDateTime,
    val shippingAddress: Address
) : Order

// 発送済み注文：発送され、追跡可能な注文
data class ShippedOrder(
    override val orderId: String,
    override val customerId: String,
    override val items: List<OrderItem>,
    val paymentDate: LocalDateTime,
    val shippingAddress: Address,
    val trackingNumber: String,
    val shippedAt: LocalDateTime
) : Order
```

**メリット**:
- 各概念の責務が明確になる
- 新しい概念を追加しても、既存のコードに影響を与えない
- ドメインの理解が深まる
- 拡張性と柔軟性が高い

## モデリングのステップ：具体と抽象を行き来する

### ステップ1: 具体例を観察する（ドメインの観察）

**例：オンラインコースシステム**

具体例を観察します：

**有料コースの例**:
- コース名: "実践英文法マスター"
- 作成日: "2020年1月1日"
- 価格: "9800円"
- 受講期間: "6ヶ月"
- 修了証発行: あり

**無料コースの例**:
- コース名: "英語初心者入門"
- 作成日: "2021年3月15日"

### ステップ2: 共通点と違いを見つける

**共通点**:
- コース名
- 作成日

**違い**:
- 有料コースは価格、受講期間、修了証発行を持つ
- 無料コースは価格、受講期間、修了証発行を持たない

### ステップ3: 概念の分離を決定する

**質問**: 有料コースと無料コースは、同じ概念として扱えるか？それとも別々の概念として扱うべきか？

**判断**:
- 有料コースと無料コースは、異なる意味と用途を持つ
- 有料コースは「有料で提供されるコース」、無料コースは「無料で提供されるコース」
- 異なるビジネスルールが適用される（価格計算、受講期間の管理など）
- それぞれ独立して管理・更新される

**結論**: 有料コースと無料コースは、**別々の概念として扱うべき**

### ステップ4: 抽象的なモデルを設計する

**共通の概念**: 「コース」という共通の概念を定義し、共通の属性（コース名、作成日）を定義する

**各概念に固有の属性**:
- 有料コース: 価格、受講期間、修了証発行
- 無料コース: 固有の属性なし（共通の属性のみ）

**設計**:
```
コース（共通の概念）
├── 有料コース（価格、受講期間、修了証発行を持つ）
└── 無料コース（共通の属性のみ）
```

### ステップ5: 具体例で検証する

抽象化したモデルが、元の具体例を正しく表現できるか確認します：

- ✅ 有料コースの例を表現できるか？ → はい
- ✅ 無料コースの例を表現できるか？ → はい
- ✅ 不正な状態（有料コースなのに価格がない）を作れないか？ → はい
- ✅ ドメインの理解を正しく表現できているか？ → はい

### ステップ6: 抽象と具体を往復する

抽象化したモデルから、新しい具体例を導きます：

**新しい具体例**: 「期間限定無料コース」（無料だが、受講期間が限定されている）

この新しい具体例から、さらに抽象化を改善します：

**改善案**: 「無料コース」をさらに細分化する必要があるか？

- 「通常の無料コース」: 受講期間の制限なし
- 「期間限定無料コース」: 受講期間が限定されている

**判断**: これらは異なる概念として扱うべきか？

- 「通常の無料コース」と「期間限定無料コース」は、異なる意味と用途を持つ
- 異なるビジネスルールが適用される（受講期間の管理など）

**結論**: 「通常の無料コース」と「期間限定無料コース」は、**別々の概念として扱うべき**

このように、抽象と具体を往復することで、モデルが洗練されていきます。

## 実践例：概念の分離と責務の明確化

### 例1: 決算情報と株価情報

**ドメインの観察**:
- 決算情報: 企業の財務実績を示す（売上、営業利益、純利益、発表日）
- 株価情報: 市場での取引価格を示す（始値、高値、安値、終値、出来高）
- 両方とも「企業の財務に関する情報」という共通点がある
- しかし、意味や用途が大きく異なる

**ビジネス要件**:
- 決算情報と株価情報は異なる分析目的で使用される
- それぞれ独立して更新・管理される
- 将来的に異なる変換ルールやバリデーションが必要になる可能性がある

**概念の分離**:
決算情報と株価情報は、**別々の独立した概念として扱う**べきです。

**理由**:
- ドメイン上、決算情報と株価情報は異なる意味と用途を持つ
- 異なるビジネスルールが適用される
- それぞれ独立して管理・更新される
- 将来的な変更にも柔軟に対応できる

**設計**:
```
決算情報（独立した概念）
├── 企業ID
├── 日付
├── 売上
├── 営業利益
├── 純利益
└── 発表日

株価情報（独立した概念）
├── 企業ID
├── 日付
├── 始値
├── 高値
├── 安値
├── 終値
└── 出来高
```

共通の属性（企業ID、日付）があっても、それらは各概念の文脈で意味が異なる可能性があるため、統合する必要はありません。

### 例2: ユーザータイプ

**ドメインの観察**:
- 一般ユーザー: 基本的な機能のみ利用可能
- プレミアムユーザー: サブスクリプション契約により追加機能を利用可能（契約開始日、プラン種別）
- アナリストユーザー: 組織に所属し、専門的な分析機能を利用可能（所属組織、資格情報）
- 全てのユーザーに共通する属性: 名前、メール、パスワード、登録日

**ビジネス要件**:
- ユーザータイプごとに異なる権限と機能が提供される
- ユーザータイプは変更される可能性がある（一般→プレミアムへのアップグレードなど）
- 各ユーザータイプで異なるビジネスルールが適用される

**概念の分離**:
3つのユーザータイプは、**「ユーザー」という共通の概念の下に、それぞれ独立した概念として扱う**べきです。

**理由**:
- ドメイン上、3つのユーザータイプは異なる意味と用途を持つ
- 異なる権限と機能を持ち、異なるビジネスルールが適用される
- 共通の属性（名前、メール、パスワード、登録日）があることは、共通の概念を定義する理由になる
- 各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる

**設計**:
```
ユーザー（共通の概念）
├── 名前
├── メール
├── パスワード
└── 登録日

├── 一般ユーザー（共通の属性のみ）
├── プレミアムユーザー（契約開始日、プラン種別）
└── アナリストユーザー（所属組織、資格情報）
```

### 例3: ニュース記事とレポート

**ドメインの観察**:
- ニュース記事: 一般向けの情報発信（タイトル、本文、公開日、著者、タグ、閲覧数）
- レポート: 企業向けの専門的な分析（タイトル、本文、公開日、著者、対象企業、レポート種別、PDF URL）
- 両方とも「公開されるコンテンツ」という共通点がある
- しかし、目的や読者層が大きく異なる

**ビジネス要件**:
- ニュース記事とレポートは異なる公開ルールとアクセス制御が適用される
- それぞれ独立して管理・更新される
- 将来的に異なる分析や集計が必要になる可能性がある

**概念の分離**:
ニュース記事とレポートは、**「コンテンツ」という共通の概念の下に、それぞれ独立した概念として扱う**べきです。

**理由**:
- ドメイン上、ニュース記事とレポートは異なる目的と読者層を持つ
- 異なる公開ルールとアクセス制御が適用される
- 両方とも「公開されるコンテンツ」という共通点があるため、共通の概念の下に定義することで、ドメインの理解が深まる
- 各タイプ固有の属性は各概念に定義することで、それぞれの責務が明確になる

**設計**:
```
コンテンツ（共通の概念）
├── タイトル
├── 本文
├── 公開日
└── 著者

├── ニュース記事（タグ、閲覧数）
└── レポート（対象企業、レポート種別、PDF URL）
```

## モデリング前チェックリスト

実際にクラスやフィールドを書く前に、次の順番で考えると失敗が減ります。

### Phase 1: ドメイン理解

1. **これはどんな「言葉」で説明される概念か？**
   ドメインエキスパートが使っている名詞・動詞を、そのままクラス名・メソッド名にできますか？

2. **これらの具体例は、同じ概念として扱えるか？それとも別々の概念として扱うべきか？**
   - 同じ意味と用途を持つ → 同じ概念として扱う
   - 異なる意味と用途を持つ → 別々の概念として扱う

3. **ドメインエキスパートに説明して理解してもらえるか？**
   技術用語（DB、APIなど）でドメイン概念を表現していないか？

### Phase 2: 概念の分離と責務

1. **共通の属性は何か？**
   全ての具体例に共通する属性を特定します。

2. **各概念に固有の属性は何か？**
   各具体例に固有の属性を特定します。

3. **各概念の責務は何か？**
   各概念が何を担当すべきかを明確にします。

4. **概念の境界は適切か？**
   概念が大きすぎないか、小さすぎないかを確認します。

### Phase 3: 抽象化の検証

1. **抽象化したモデルが、元の具体例を正しく表現できるか？**
   全ての具体例を表現できるか確認します。

2. **不正な状態を作れないか？**
   ドメイン上存在しない状態を表現できないか確認します。

3. **ドメインの理解を正しく表現できているか？**
   ドメインエキスパートに説明して理解してもらえるか確認します。

### Phase 4: 抽象と具体の往復

1. **抽象化したモデルから、新しい具体例を導けるか？**
   抽象化したモデルが、新しい具体例を導けるか確認します。

2. **新しい具体例から、さらに抽象化を改善できるか？**
   新しい具体例から、さらに抽象化を改善できるか確認します。

3. **継続的に改善できるか？**
   抽象と具体を往復することで、モデルが洗練されていくか確認します。

## よくある間違いとその対処法

### 間違い1: 異なる概念を同じ概念として扱う

**症状**:
異なる意味と用途を持つ概念を、1つの概念として扱い、typeフィールドやnullableフィールドで区別する。

**問題点**:
- ドメインの概念を適切に表現できていない
- それぞれの概念の責務が曖昧になる
- 不正な状態を表現できてしまう

**対処法**:
異なる概念は、**別々の独立した概念として扱う**べきです。共通の属性がある場合は、共通の概念（interface）を定義し、各概念に固有の属性は各概念に定義します。

### 間違い2: sealed classで状態遷移を表現する

**症状**:
sealed classを使って、状態遷移を表現する。

**問題点**:
- ドメインの概念を適切に分離できていない
- 状態遷移として扱っているが、実際には概念の変換として扱うべき
- 拡張性と柔軟性が欠如している

**対処法**:
sealed classを使わず、**概念を分離し、それぞれを独立した概念として扱う**べきです。状態遷移ではなく、概念の変換として扱います。

### 間違い3: 抽象化が不十分

**症状**:
具体例から抽象化する際に、共通点と違いを適切に見つけられない。

**問題点**:
- 抽象化が不十分で、モデルが複雑になる
- 概念の分離が適切でない

**対処法**:
**具体と抽象を往復する**ことで、抽象化を改善します。抽象化したモデルから新しい具体例を導き、その具体例からさらに抽象化を改善します。

## まとめ

- **具体から抽象へ**: 複数の具体例から共通パターンを抽出し、概念を適切に分離する
- **抽象から具体へ**: 抽象的なモデルから、具体的な実装例を導く
- **往復する**: 具体と抽象を行き来することで、理解が深まり、モデルが洗練される
- **概念の分離**: 異なる意味と用途を持つ概念は、別々の概念として明確に分離する
- **責務の明確化**: 各概念の責務を明確にし、それぞれが何を担当すべきかを明確にする
- **sealed classを使わない**: sealed classを使う時点で、モデリングに失敗している可能性が高い

モデリングは練習によって上達します。日常的に具体例を観察し、抽象化する習慣を身につけましょう。

**次のステップ**:
1. 身の回りの概念を1つ選び、具体例を観察する
2. 共通点と違いを見つけ、概念の分離を決定する
3. 抽象的なモデルを設計し、具体例で検証する
4. 抽象と具体を往復し、モデルを洗練する
